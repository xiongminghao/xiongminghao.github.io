<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XMH的个人网站</title>
  
  
  <link href="https://nanxiaoxiong.com/atom.xml" rel="self"/>
  
  <link href="https://nanxiaoxiong.com/"/>
  <updated>2021-09-28T14:34:21.164Z</updated>
  <id>https://nanxiaoxiong.com/</id>
  
  <author>
    <name>MingHao Xiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题记录</title>
    <link href="https://nanxiaoxiong.com/2021/09/28/offer/"/>
    <id>https://nanxiaoxiong.com/2021/09/28/offer/</id>
    <published>2021-09-28T14:33:04.000Z</published>
    <updated>2021-09-28T14:34:21.164Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="https://nanxiaoxiong.com/2021/09/28/springboot/"/>
    <id>https://nanxiaoxiong.com/2021/09/28/springboot/</id>
    <published>2021-09-28T14:30:00.000Z</published>
    <updated>2021-09-28T14:32:34.346Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learner.blog.csdn.net/article/details/88925013">https://learner.blog.csdn.net/article/details/88925013</a></p><p>后端开发入门</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learner.blog.csdn.net/article/details/88925013&quot;&gt;https://learner.blog.csdn.net/article/details/88925013&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后端开发入门</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://nanxiaoxiong.com/2021/08/31/linklist/"/>
    <id>https://nanxiaoxiong.com/2021/08/31/linklist/</id>
    <published>2021-08-31T15:03:17.000Z</published>
    <updated>2021-08-31T15:05:18.644Z</updated>
    
    <content type="html"><![CDATA[<p>Java中单链表定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">      int val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode() &#123;&#125;</span><br><span class="line">      ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">      ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>初始状态：两个指针均指向头结点</p><p>快指针：一次走两步 （也有可能是先走，一次走一步）</p><p>慢指针：一次走一步</p><p>那么，如果结点个数为奇数个，当快指针走到最后一个结点时，慢指针正好指向中间结点</p><p>如果结点个数为偶数个，链表没有中间结点，或者可以说有两个中间结点，当快指针为空时，慢指针指向后中间结点，当快指针走到倒数第二个结点时，慢指针指向前中间结点，这些判断条件也会随着初始状态的不同而改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode fast=head;</span><br><span class="line">ListNode slow=head;</span><br><span class="line">while(p.next!=null&amp;&amp;p.next.next!=null)&#123;</span><br><span class="line">    //p.next==null指p走到最后一个结点</span><br><span class="line">    //p.next.next==null指p走到倒数第二个结点</span><br><span class="line">    slow=slow.next;</span><br><span class="line">    fast=fast.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时的slow就是链表的中间结点或前中间结点<br><img src="/2021/08/31/linklist/%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.png"></p><p>延伸1：如果快指针与慢指针相遇了，那么链表一定有环</p><p>如果链表没有环，那么快指针永远在慢指针前面，并且差距越拉越大，永远不可能相遇，但是如果链表有环，那么快指针走着走着就会沿着环循环了，这时慢指针会逐渐跟上，并且二者一定会在环的某个结点相遇（想象一下操场跑步）</p><p>只考虑两个指针第一次相遇（头结点不算），这时经过了时间t，慢指针走了t步，快指针走了2t步，快指针一定比慢指针多走了n圈，也就是路程差距t一定是环长的整数倍，再代换一下，慢指针走的路程t一定是环长的整数倍，那么，这时再让两个指针一个从头，一个从相遇处开始走，这两个指针相遇的地方就是环的入口<br><img src="/2021/08/31/linklist/%E7%8E%AF.png"></p><p>延伸2：这次快指针一次走一步，但快指针先走一段时间后慢指针再开始走，如果快指针先走n步，之后慢指针才开始走，两者都是一次一步，那么当快指针为空时，慢指针正好指向链表倒数第n个结点</p><p>假设链表长度为N（N&gt;=n），快指针走了n步之后，其后面还有（N-1-n）个结点，这时慢指针开始走，当快指针指向空结点时，又经过了（N-n）步，那么经过这（N-n）步慢指针指向了第（N-n+1）个结点，它后面还有（n-1）个结点，那么它就是倒数第n个结点<br><img src="/2021/08/31/linklist/%E5%80%92%E6%95%B0%E7%BB%93%E7%82%B9.png"></p><h1 id="前驱指针"><a href="#前驱指针" class="headerlink" title="前驱指针"></a>前驱指针</h1><p>一般情况下，单链表只有后继指针，用于访问目前结点的下一个结点，但是有些情况下也需要访问目前结点的前一个结点，我们可以定义一个pre指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode p=head;</span><br><span class="line">ListNode pre=null;</span><br><span class="line">while(p!=null)&#123;</span><br><span class="line">  pre=p;</span><br><span class="line">  p=p.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要访问某个结点的上一个结点时，就可以遍历到这个结点，pre就指向了它的前驱</p><p>//TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java中单链表定义&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="https://nanxiaoxiong.com/2021/08/12/blog3/"/>
    <id>https://nanxiaoxiong.com/2021/08/12/blog3/</id>
    <published>2021-08-12T06:35:51.000Z</published>
    <updated>2021-09-13T12:39:55.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h1><p>给你二叉树的根节点root ，返回它节点值的前序遍历。</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内</p><p>-100 &lt;= Node.val &lt;= 100</p><h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><p>最简单的写法，不会的可以入土了<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">       if(root==null)</span><br><span class="line">         return list;</span><br><span class="line">       list.add(root.val);</span><br><span class="line">       preorderTraversal(root.left);</span><br><span class="line">       preorderTraversal(root.right);</span><br><span class="line">       return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="迭代写法1"><a href="#迭代写法1" class="headerlink" title="迭代写法1"></a>迭代写法1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">       List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">       TreeNode cur=root;</span><br><span class="line">       while(cur!=null||!stack.isEmpty())&#123;</span><br><span class="line">           while(cur!=null)&#123;</span><br><span class="line">               list.add(cur.val);</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur=cur.left;</span><br><span class="line">           &#125;</span><br><span class="line">           cur=stack.pop();</span><br><span class="line">           cur=cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代写法2"><a href="#迭代写法2" class="headerlink" title="迭代写法2"></a>迭代写法2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">       List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">       if(root==null)</span><br><span class="line">          return list;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">       stack.push(root);</span><br><span class="line">       TreeNode cur;</span><br><span class="line">       while(!stack.isEmpty())&#123;</span><br><span class="line">           cur=stack.pop();</span><br><span class="line">           list.add(cur.val);</span><br><span class="line">           if(cur.right!=null)//先进后出</span><br><span class="line">              stack.push(cur.right);</span><br><span class="line">           if(cur.left!=null)</span><br><span class="line">              stack.push(cur.left);</span><br><span class="line">       &#125;</span><br><span class="line">       return list; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><p>给定一个二叉树的根节点 root ，返回它的中序遍历。</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内</p><p>-100 &lt;= Node.val &lt;= 100</p><h2 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">   public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">      if(root==null)</span><br><span class="line">        return list;</span><br><span class="line">      inorderTraversal(root.left);</span><br><span class="line">      list.add(root.val);</span><br><span class="line">      inorderTraversal(root.right);</span><br><span class="line">      return list;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">       List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">       TreeNode cur=root;</span><br><span class="line">       while(cur!=null||!stack.isEmpty())&#123;</span><br><span class="line">           while(cur!=null)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur=cur.left;</span><br><span class="line">           &#125;</span><br><span class="line">           cur=stack.pop();</span><br><span class="line">           list.add(cur.val);</span><br><span class="line">           cur=cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h1><p>给定一个二叉树，返回它的后序遍历。</p><h2 id="递归写法-2"><a href="#递归写法-2" class="headerlink" title="递归写法"></a>递归写法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">      if(root==null)</span><br><span class="line">        return list;</span><br><span class="line">      postorderTraversal(root.left);</span><br><span class="line">      postorderTraversal(root.right);</span><br><span class="line">      list.add(root.val);</span><br><span class="line">      return list;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法1-1"><a href="#迭代写法1-1" class="headerlink" title="迭代写法1"></a>迭代写法1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">      List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">      Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">      TreeNode cur=root;</span><br><span class="line">      TreeNode pre=null;</span><br><span class="line">      while(cur!=null||!stack.isEmpty())&#123;</span><br><span class="line">          while(cur!=null)&#123;</span><br><span class="line">              stack.push(cur);</span><br><span class="line">              cur=cur.left;</span><br><span class="line">          &#125;</span><br><span class="line">          cur=stack.pop();</span><br><span class="line">          if(cur.right==null||cur.right==pre)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=null;</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代写法2-1"><a href="#迭代写法2-1" class="headerlink" title="迭代写法2"></a>迭代写法2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode cur;</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            if (cur.left != null)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur.right != null)&#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144.二叉树的前序遍历&quot;&gt;&lt;/a&gt;144.二叉树的前序遍历&lt;/h1&gt;&lt;p&gt;给你二叉树的根节点root ，返回它节点值的前序遍历。&lt;/p</summary>
      
    
    
    
    
    <category term="二叉树" scheme="https://nanxiaoxiong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="https://nanxiaoxiong.com/2021/08/04/blog2/"/>
    <id>https://nanxiaoxiong.com/2021/08/04/blog2/</id>
    <published>2021-08-04T14:35:51.000Z</published>
    <updated>2021-08-04T15:08:29.375Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先搜索（DFS）模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(a,x,y)&#123;</span><br><span class="line">if(终止条件)</span><br><span class="line">&#123;</span><br><span class="line">//什么都不做（也许）</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">DFS(a,x+1,y);</span><br><span class="line">...</span><br><span class="line">return 结果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止反复横跳（左访问右，之后右又访问左），访问过的地方要变更一下值并设置在终止条件里。</p><p>变更后的值不用恢复，因为变了就代表访问过了，根据DFS定义，后面的点根本访问不到这个点，不会影响结果。</p><p>一般都是先给一个初始值，对这个初始值进行递归，假设对一个二维数组中某个点开始DFS，并计算递归次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int result=DFS(a,i,j);//数组为a，后面i,j代表下标</span><br><span class="line">DFS(int[][] a,int i,int j)//数组为a，后面x,y代表下标</span><br><span class="line">if(i&lt;0||j&lt;0||i&gt;=a.length||j&gt;=a[0].length||a[i][j]!=4396)//终止条件，其中i,j可以取到0</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    int count=1;</span><br><span class="line">    a[i][j]=4396;</span><br><span class="line">    count+=DFS(a,i+1,j);//一直向上递归</span><br><span class="line">    //count+=DFS(a,i-1,j);一直向下递归</span><br><span class="line">    //count+=DFS(a,i,j+1);一直向右递归</span><br><span class="line">    //count+=DFS(a,i,j-1);一直向左递归</span><br><span class="line">    //...</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于二叉树,99%是对自身左叶子节点和右叶子结点递归，终止条件：自身是否为null</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先搜索（DFS）模板&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习环境配置</title>
    <link href="https://nanxiaoxiong.com/2021/05/18/blog1/"/>
    <id>https://nanxiaoxiong.com/2021/05/18/blog1/</id>
    <published>2021-05-18T15:07:01.000Z</published>
    <updated>2021-05-20T14:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>github上的代码版本太多,tensorflow1,tensorflow2,pytorch<br>于是决定同时在电脑上安装这三个<br>使用anaconda3:<br>注意：anaconda安装路径不能带有中文，win10用户名文件夹不能为中文，否则后面安装各种包可能会有error<br>找到版本对应的CUDA与cudnn<br>如果显卡很好的话CUDA要装10以上<br>安装版本:<br>pytorch 1.2.0<br>tensorflow-gpu 1.13.2<br>tensorflow-gpu 2.2.0<br>需要CUDA10.0+CUDA10.1两个版本，是可以共存的，安装路径不能相同<br>具体参考：<br><a href="https://blog.csdn.net/weixin_44791964/article/details/104702142">https://blog.csdn.net/weixin_44791964/article/details/104702142</a><br><a href="https://blog.csdn.net/weixin_44791964/article/details/106037141">https://blog.csdn.net/weixin_44791964/article/details/106037141</a><br><a href="https://blog.csdn.net/weixin_44791964/article/details/109161493?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_44791964/article/details/109161493?spm=1001.2014.3001.5501</a><br>conda建好三个环境就可以开始学习了，还要测试是否用了gpu而不是cpu<br>在pytorch环境中测试：<br>torch.cuda.is_available()<br>在tensorflow1和2环境中测试：<br>tensorflow.gpu.is_available()<br>都返回Ture就没问题了<br>还需要在对应环境中下载pillow（PIL）等包，运行时根据错误提示缺什么下什么即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;github上的代码版本太多,tensorflow1,tensorflow2,pytorch&lt;br&gt;于是决定同时在电脑上安装这三个&lt;br&gt;使用anaconda3:&lt;br&gt;注意：anaconda安装路径不能带有中文，win10用户名文件夹不能为中文，否则后面安装各种包可能会有</summary>
      
    
    
    
    
  </entry>
  
</feed>
