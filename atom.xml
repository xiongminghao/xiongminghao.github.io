<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XMH的个人网站</title>
  
  
  <link href="https://nanxiaoxiong.com/atom.xml" rel="self"/>
  
  <link href="https://nanxiaoxiong.com/"/>
  <updated>2021-08-31T15:05:18.644Z</updated>
  <id>https://nanxiaoxiong.com/</id>
  
  <author>
    <name>MingHao Xiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单链表</title>
    <link href="https://nanxiaoxiong.com/2021/08/31/linklist/"/>
    <id>https://nanxiaoxiong.com/2021/08/31/linklist/</id>
    <published>2021-08-31T15:03:17.000Z</published>
    <updated>2021-08-31T15:05:18.644Z</updated>
    
    <content type="html"><![CDATA[<p>Java中单链表定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">      int val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode() &#123;&#125;</span><br><span class="line">      ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">      ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>初始状态：两个指针均指向头结点</p><p>快指针：一次走两步 （也有可能是先走，一次走一步）</p><p>慢指针：一次走一步</p><p>那么，如果结点个数为奇数个，当快指针走到最后一个结点时，慢指针正好指向中间结点</p><p>如果结点个数为偶数个，链表没有中间结点，或者可以说有两个中间结点，当快指针为空时，慢指针指向后中间结点，当快指针走到倒数第二个结点时，慢指针指向前中间结点，这些判断条件也会随着初始状态的不同而改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode fast=head;</span><br><span class="line">ListNode slow=head;</span><br><span class="line">while(p.next!=null&amp;&amp;p.next.next!=null)&#123;</span><br><span class="line">    //p.next==null指p走到最后一个结点</span><br><span class="line">    //p.next.next==null指p走到倒数第二个结点</span><br><span class="line">    slow=slow.next;</span><br><span class="line">    fast=fast.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时的slow就是链表的中间结点或前中间结点<br><img src="/2021/08/31/linklist/%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.png"></p><p>延伸1：如果快指针与慢指针相遇了，那么链表一定有环</p><p>如果链表没有环，那么快指针永远在慢指针前面，并且差距越拉越大，永远不可能相遇，但是如果链表有环，那么快指针走着走着就会沿着环循环了，这时慢指针会逐渐跟上，并且二者一定会在环的某个结点相遇（想象一下操场跑步）</p><p>只考虑两个指针第一次相遇（头结点不算），这时经过了时间t，慢指针走了t步，快指针走了2t步，快指针一定比慢指针多走了n圈，也就是路程差距t一定是环长的整数倍，再代换一下，慢指针走的路程t一定是环长的整数倍，那么，这时再让两个指针一个从头，一个从相遇处开始走，这两个指针相遇的地方就是环的入口<br><img src="/2021/08/31/linklist/%E7%8E%AF.png"></p><p>延伸2：这次快指针一次走一步，但快指针先走一段时间后慢指针再开始走，如果快指针先走n步，之后慢指针才开始走，两者都是一次一步，那么当快指针为空时，慢指针正好指向链表倒数第n个结点</p><p>假设链表长度为N（N&gt;=n），快指针走了n步之后，其后面还有（N-1-n）个结点，这时慢指针开始走，当快指针指向空结点时，又经过了（N-n）步，那么经过这（N-n）步慢指针指向了第（N-n+1）个结点，它后面还有（n-1）个结点，那么它就是倒数第n个结点<br><img src="/2021/08/31/linklist/%E5%80%92%E6%95%B0%E7%BB%93%E7%82%B9.png"></p><h1 id="前驱指针"><a href="#前驱指针" class="headerlink" title="前驱指针"></a>前驱指针</h1><p>一般情况下，单链表只有后继指针，用于访问目前结点的下一个结点，但是有些情况下也需要访问目前结点的前一个结点，我们可以定义一个pre指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode p=head;</span><br><span class="line">ListNode pre=null;</span><br><span class="line">while(p!=null)&#123;</span><br><span class="line">  pre=p;</span><br><span class="line">  p=p.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要访问某个结点的上一个结点时，就可以遍历到这个结点，pre就指向了它的前驱</p><p>//TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java中单链表定义&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="https://nanxiaoxiong.com/2021/08/12/blog3/"/>
    <id>https://nanxiaoxiong.com/2021/08/12/blog3/</id>
    <published>2021-08-12T06:35:51.000Z</published>
    <updated>2021-08-12T08:07:16.713Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，二叉树的（前/中/后）遍历有两种（递归/非递归）<br>递归的方法很简单，这里记录一下非递归的遍历方式<br>递归本质也就是用栈来保存每一次的结果<br>所以非递归的方式也就是要用一个栈来保存遍历过的二叉树节点</p><p>以前序遍历为例：</p><p>1.每拿到一个节点就把它保存在栈中</p><p>2.继续对这个节点的左子树重复过程1，直到左子树为空</p><p>3.因为保存在栈中的节点都遍历了左子树但是没有遍历右子树，所以对栈中节点出栈 并对它的右子树重复过程1</p><p>4.直到遍历完所有节点</p><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>根 - &gt; 左 - &gt; 右</p><p>入栈顺序即为前序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(root!=null)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>左 - &gt; 根- &gt; 右</p><p>出栈顺序即为中序遍历，改变一下写入列表的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(root!=null)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>左 - &gt; 右- &gt; 根</p><p>我们将前序遍历中节点插入列表尾部的逻辑，修改为将节点插入列表的头部</p><p>那么结果链表就变为了：右 -&gt; 左 -&gt; 根</p><p>我们将遍历的顺序由从左到右修改为从右到左，配合如果1</p><p>那么结果链表就变为了：左 -&gt; 右 -&gt; 根</p><p>这刚好是后序遍历的顺序</p><p>这里使用的本质还是前序遍历，常规的解法更复杂一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(root!=null)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(0,root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>层次遍历没有递归的算法，所以不使用栈，使用队列</p><p>先将根节点入队，之后出队，将其左孩子与右孩子入队，左孩子出队，左孩子的左右孩子入队，右孩子出队，右孩子的左右孩子入队。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; HierarchicalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;TreeNode&gt;&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(root);</span><br><span class="line">        lists.add(list);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=queue.size();</span><br><span class="line">            List&lt;TreeNode&gt; tlist=new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                root=queue.poll();</span><br><span class="line">                if(root.left!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(root.left);</span><br><span class="line">                    tlist.add(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(root.right);</span><br><span class="line">                    tlist.add(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tlist.size()!=0)</span><br><span class="line">                lists.add(tlist);</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，二叉树的（前/中/后）遍历有两种（递归/非递归）&lt;br&gt;递归的方法很简单，这里记录一下非递归的遍历方式&lt;br&gt;递归本质也就是用栈来保存每一次的结果&lt;br&gt;所以非递归的方式也就是要用一个栈来保存遍历过的二叉树节点&lt;/p&gt;
&lt;p&gt;以前序遍历为例：&lt;/p&gt;
&lt;p&gt;1.每</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="https://nanxiaoxiong.com/2021/08/04/blog2/"/>
    <id>https://nanxiaoxiong.com/2021/08/04/blog2/</id>
    <published>2021-08-04T14:35:51.000Z</published>
    <updated>2021-08-04T15:08:29.375Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先搜索（DFS）模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(a,x,y)&#123;</span><br><span class="line">if(终止条件)</span><br><span class="line">&#123;</span><br><span class="line">//什么都不做（也许）</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">DFS(a,x+1,y);</span><br><span class="line">...</span><br><span class="line">return 结果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止反复横跳（左访问右，之后右又访问左），访问过的地方要变更一下值并设置在终止条件里。</p><p>变更后的值不用恢复，因为变了就代表访问过了，根据DFS定义，后面的点根本访问不到这个点，不会影响结果。</p><p>一般都是先给一个初始值，对这个初始值进行递归，假设对一个二维数组中某个点开始DFS，并计算递归次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int result=DFS(a,i,j);//数组为a，后面i,j代表下标</span><br><span class="line">DFS(int[][] a,int i,int j)//数组为a，后面x,y代表下标</span><br><span class="line">if(i&lt;0||j&lt;0||i&gt;=a.length||j&gt;=a[0].length||a[i][j]!=4396)//终止条件，其中i,j可以取到0</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    int count=1;</span><br><span class="line">    a[i][j]=4396;</span><br><span class="line">    count+=DFS(a,i+1,j);//一直向上递归</span><br><span class="line">    //count+=DFS(a,i-1,j);一直向下递归</span><br><span class="line">    //count+=DFS(a,i,j+1);一直向右递归</span><br><span class="line">    //count+=DFS(a,i,j-1);一直向左递归</span><br><span class="line">    //...</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于二叉树,99%是对自身左叶子节点和右叶子结点递归，终止条件：自身是否为null</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先搜索（DFS）模板&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习环境配置</title>
    <link href="https://nanxiaoxiong.com/2021/05/18/blog1/"/>
    <id>https://nanxiaoxiong.com/2021/05/18/blog1/</id>
    <published>2021-05-18T15:07:01.000Z</published>
    <updated>2021-05-20T14:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>github上的代码版本太多,tensorflow1,tensorflow2,pytorch<br>于是决定同时在电脑上安装这三个<br>使用anaconda3:<br>注意：anaconda安装路径不能带有中文，win10用户名文件夹不能为中文，否则后面安装各种包可能会有error<br>找到版本对应的CUDA与cudnn<br>如果显卡很好的话CUDA要装10以上<br>安装版本:<br>pytorch 1.2.0<br>tensorflow-gpu 1.13.2<br>tensorflow-gpu 2.2.0<br>需要CUDA10.0+CUDA10.1两个版本，是可以共存的，安装路径不能相同<br>具体参考：<br><a href="https://blog.csdn.net/weixin_44791964/article/details/104702142">https://blog.csdn.net/weixin_44791964/article/details/104702142</a><br><a href="https://blog.csdn.net/weixin_44791964/article/details/106037141">https://blog.csdn.net/weixin_44791964/article/details/106037141</a><br><a href="https://blog.csdn.net/weixin_44791964/article/details/109161493?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_44791964/article/details/109161493?spm=1001.2014.3001.5501</a><br>conda建好三个环境就可以开始学习了，还要测试是否用了gpu而不是cpu<br>在pytorch环境中测试：<br>torch.cuda.is_available()<br>在tensorflow1和2环境中测试：<br>tensorflow.gpu.is_available()<br>都返回Ture就没问题了<br>还需要在对应环境中下载pillow（PIL）等包，运行时根据错误提示缺什么下什么即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;github上的代码版本太多,tensorflow1,tensorflow2,pytorch&lt;br&gt;于是决定同时在电脑上安装这三个&lt;br&gt;使用anaconda3:&lt;br&gt;注意：anaconda安装路径不能带有中文，win10用户名文件夹不能为中文，否则后面安装各种包可能会有</summary>
      
    
    
    
    
  </entry>
  
</feed>
