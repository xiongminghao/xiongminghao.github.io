[{"title":"二叉树遍历","date":"2021-08-12T06:35:51.000Z","url":"/2021/08/12/blog3/","categories":[["undefined",""]],"content":"众所周知，二叉树的（前/中/后）遍历有两种（递归/非递归）递归的方法很简单，这里记录一下非递归的遍历方式递归本质也就是用栈来保存每一次的结果所以非递归的方式也就是要用一个栈来保存遍历过的二叉树节点 以前序遍历为例： 1.每拿到一个节点就把它保存在栈中 2.继续对这个节点的左子树重复过程1，直到左子树为空 3.因为保存在栈中的节点都遍历了左子树但是没有遍历右子树，所以对栈中节点出栈 并对它的右子树重复过程1 4.直到遍历完所有节点 前序遍历根 - &gt; 左 - &gt; 右 入栈顺序即为前序遍历 中序遍历左 - &gt; 根- &gt; 右 出栈顺序即为中序遍历，改变一下写入列表的位置 后序遍历左 - &gt; 右- &gt; 根 我们将前序遍历中节点插入列表尾部的逻辑，修改为将节点插入列表的头部 那么结果链表就变为了：右 -&gt; 左 -&gt; 根 我们将遍历的顺序由从左到右修改为从右到左，配合如果1 那么结果链表就变为了：左 -&gt; 右 -&gt; 根 这刚好是后序遍历的顺序 这里使用的本质还是前序遍历，常规的解法更复杂一些 层次遍历层次遍历没有递归的算法，所以不使用栈，使用队列 先将根节点入队，之后出队，将其左孩子与右孩子入队，左孩子出队，左孩子的左右孩子入队，右孩子出队，右孩子的左右孩子入队。。。 "},{"title":"DFS","date":"2021-08-04T14:35:51.000Z","url":"/2021/08/04/blog2/","categories":[["undefined",""]],"content":"深度优先搜索（DFS）模板 为了防止反复横跳（左访问右，之后右又访问左），访问过的地方要变更一下值并设置在终止条件里。 变更后的值不用恢复，因为变了就代表访问过了，根据DFS定义，后面的点根本访问不到这个点，不会影响结果。 一般都是先给一个初始值，对这个初始值进行递归，假设对一个二维数组中某个点开始DFS，并计算递归次数 对于二叉树,99%是对自身左叶子节点和右叶子结点递归，终止条件：自身是否为null"},{"title":"深度学习环境配置","date":"2021-05-18T15:07:01.000Z","url":"/2021/05/18/blog1/","categories":[["undefined",""]],"content":"github上的代码版本太多,tensorflow1,tensorflow2,pytorch于是决定同时在电脑上安装这三个使用anaconda3:注意：anaconda安装路径不能带有中文，win10用户名文件夹不能为中文，否则后面安装各种包可能会有error找到版本对应的CUDA与cudnn如果显卡很好的话CUDA要装10以上安装版本:pytorch 1.2.0tensorflow-gpu 1.13.2tensorflow-gpu 2.2.0需要CUDA10.0+CUDA10.1两个版本，是可以共存的，安装路径不能相同具体参考：建好三个环境就可以开始学习了，还要测试是否用了gpu而不是cpu在pytorch环境中测试：torch.cuda.is_available()在tensorflow1和2环境中测试：tensorflow.gpu.is_available()都返回Ture就没问题了还需要在对应环境中下载pillow（PIL）等包，运行时根据错误提示缺什么下什么即可"}]