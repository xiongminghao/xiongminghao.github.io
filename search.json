[{"title":"单链表","date":"2021-08-31T15:03:17.000Z","url":"/2021/08/31/linklist/","categories":[["undefined",""]],"content":"Java中单链表定义 快慢指针初始状态：两个指针均指向头结点 快指针：一次走两步 （也有可能是先走，一次走一步） 慢指针：一次走一步 那么，如果结点个数为奇数个，当快指针走到最后一个结点时，慢指针正好指向中间结点 如果结点个数为偶数个，链表没有中间结点，或者可以说有两个中间结点，当快指针为空时，慢指针指向后中间结点，当快指针走到倒数第二个结点时，慢指针指向前中间结点，这些判断条件也会随着初始状态的不同而改变 那么此时的slow就是链表的中间结点或前中间结点 延伸1：如果快指针与慢指针相遇了，那么链表一定有环 如果链表没有环，那么快指针永远在慢指针前面，并且差距越拉越大，永远不可能相遇，但是如果链表有环，那么快指针走着走着就会沿着环循环了，这时慢指针会逐渐跟上，并且二者一定会在环的某个结点相遇（想象一下操场跑步） 只考虑两个指针第一次相遇（头结点不算），这时经过了时间t，慢指针走了t步，快指针走了2t步，快指针一定比慢指针多走了n圈，也就是路程差距t一定是环长的整数倍，再代换一下，慢指针走的路程t一定是环长的整数倍，那么，这时再让两个指针一个从头，一个从相遇处开始走，这两个指针相遇的地方就是环的入口 延伸2：这次快指针一次走一步，但快指针先走一段时间后慢指针再开始走，如果快指针先走n步，之后慢指针才开始走，两者都是一次一步，那么当快指针为空时，慢指针正好指向链表倒数第n个结点 假设链表长度为N（N&gt;=n），快指针走了n步之后，其后面还有（N-1-n）个结点，这时慢指针开始走，当快指针指向空结点时，又经过了（N-n）步，那么经过这（N-n）步慢指针指向了第（N-n+1）个结点，它后面还有（n-1）个结点，那么它就是倒数第n个结点 前驱指针一般情况下，单链表只有后继指针，用于访问目前结点的下一个结点，但是有些情况下也需要访问目前结点的前一个结点，我们可以定义一个pre指针 需要访问某个结点的上一个结点时，就可以遍历到这个结点，pre就指向了它的前驱 //TODO"},{"title":"二叉树遍历","date":"2021-08-12T06:35:51.000Z","url":"/2021/08/12/blog3/","categories":[["undefined",""]],"content":"众所周知，二叉树的（前/中/后）遍历有两种（递归/非递归）递归的方法很简单，这里记录一下非递归的遍历方式递归本质也就是用栈来保存每一次的结果所以非递归的方式也就是要用一个栈来保存遍历过的二叉树节点 以前序遍历为例： 1.每拿到一个节点就把它保存在栈中 2.继续对这个节点的左子树重复过程1，直到左子树为空 3.因为保存在栈中的节点都遍历了左子树但是没有遍历右子树，所以对栈中节点出栈 并对它的右子树重复过程1 4.直到遍历完所有节点 前序遍历根 - &gt; 左 - &gt; 右 入栈顺序即为前序遍历 中序遍历左 - &gt; 根- &gt; 右 出栈顺序即为中序遍历，改变一下写入列表的位置 后序遍历左 - &gt; 右- &gt; 根 我们将前序遍历中节点插入列表尾部的逻辑，修改为将节点插入列表的头部 那么结果链表就变为了：右 -&gt; 左 -&gt; 根 我们将遍历的顺序由从左到右修改为从右到左，配合如果1 那么结果链表就变为了：左 -&gt; 右 -&gt; 根 这刚好是后序遍历的顺序 这里使用的本质还是前序遍历，常规的解法更复杂一些 层次遍历层次遍历没有递归的算法，所以不使用栈，使用队列 先将根节点入队，之后出队，将其左孩子与右孩子入队，左孩子出队，左孩子的左右孩子入队，右孩子出队，右孩子的左右孩子入队。。。 "},{"title":"DFS","date":"2021-08-04T14:35:51.000Z","url":"/2021/08/04/blog2/","categories":[["undefined",""]],"content":"深度优先搜索（DFS）模板 为了防止反复横跳（左访问右，之后右又访问左），访问过的地方要变更一下值并设置在终止条件里。 变更后的值不用恢复，因为变了就代表访问过了，根据DFS定义，后面的点根本访问不到这个点，不会影响结果。 一般都是先给一个初始值，对这个初始值进行递归，假设对一个二维数组中某个点开始DFS，并计算递归次数 对于二叉树,99%是对自身左叶子节点和右叶子结点递归，终止条件：自身是否为null"},{"title":"深度学习环境配置","date":"2021-05-18T15:07:01.000Z","url":"/2021/05/18/blog1/","categories":[["undefined",""]],"content":"github上的代码版本太多,tensorflow1,tensorflow2,pytorch于是决定同时在电脑上安装这三个使用anaconda3:注意：anaconda安装路径不能带有中文，win10用户名文件夹不能为中文，否则后面安装各种包可能会有error找到版本对应的CUDA与cudnn如果显卡很好的话CUDA要装10以上安装版本:pytorch 1.2.0tensorflow-gpu 1.13.2tensorflow-gpu 2.2.0需要CUDA10.0+CUDA10.1两个版本，是可以共存的，安装路径不能相同具体参考：建好三个环境就可以开始学习了，还要测试是否用了gpu而不是cpu在pytorch环境中测试：torch.cuda.is_available()在tensorflow1和2环境中测试：tensorflow.gpu.is_available()都返回Ture就没问题了还需要在对应环境中下载pillow（PIL）等包，运行时根据错误提示缺什么下什么即可"}]